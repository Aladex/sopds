#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import mysql.connector
from mysql.connector import errorcode

##########################################################################
# Глобальные переменные
#
PY_PATH=os.path.dirname(os.path.abspath(__file__))
(ROOT_PATH,tmp)=os.path.split(PY_PATH)
CFG_FILENAME='sopds.conf'
CFG_PATH_DEFAULT=ROOT_PATH+os.path.sep+'conf'+os.path.sep+CFG_FILENAME

##########################################################################
# Наименования таблиц БД
#
DB_PREFIX=""
TBL_BOOKS=DB_PREFIX+"books"
TBL_TAGS=DB_PREFIX+"tags"
TBL_BTAGS=DB_PREFIX+"btags"
TBL_CATALOGS=DB_PREFIX+"catalogs"

##########################################################################
# Считываем параметры командной строки
# пример возможных параметров
# sopds-scan.py <--scanfull | --scanlast | --scan | -s> [ [-c <configfile>]
#
# -s, --scan, --scanfull  - Полное пересканирование всех файлов библиотеки
# --scanlast              - Обрабатываются только файлы с датой поздней, чем дата последнего сканирования
# -v, --verbose           - Включить вывод отладочной информации
# -c <configfile>         - Указывается путь к файлу конфигурации

from optparse import OptionParser
from sys import argv

parser=OptionParser(conflict_handler="resolve", version="sopds-scan.py. Version 0.01a", add_help_option=True, usage='sopds-scan.py [options]', description='sopds-scan.py: Simple OPDS Scanner - programm for scan your books directory and store data to MYSQL database.')
parser.add_option('-s','--scan','--scanfull', action='store_true', dest='scanfull', default=True, help='Full rescan all stored files.')
parser.add_option('-l','--scanlast', action='store_false', dest='scanfull', default=True, help='Scan files from date after last scan.')
parser.add_option('-v','--verbose', action='store_true', dest='verbose', default=False, help='Enable verbose output')
parser.add_option('-c','--config', action='store', dest='configfile', type='string', default=CFG_PATH_DEFAULT, help='Set configuration file. By default is '+CFG_PATH_DEFAULT+'.')
(options,arguments)=parser.parse_args()

CFG_PATH=options.configfile
SCAN_FULL=options.scanfull
VERBOSE=options.verbose

if VERBOSE:
	print('Options set: scanfull =',SCAN_FULL,', verbose =',VERBOSE,', configfile =',CFG_PATH)

###########################################################################
# Считываем конфигурацию из конфигурационного файла
# используем модуль configparser

import configparser
config=configparser.ConfigParser()
config.read(CFG_PATH)

CFG_S_GLOBAL='global'
DB_NAME=config.get(CFG_S_GLOBAL,'db_name')
DB_USER=config.get(CFG_S_GLOBAL,'db_user')
DB_PASS=config.get(CFG_S_GLOBAL,'db_pass')
DB_HOST=config.get(CFG_S_GLOBAL,'db_host')
DB_CHARSET=config.get(CFG_S_GLOBAL,'db_charset')
ROOT_LIB=os.path.abspath(config.get(CFG_S_GLOBAL,'root_lib'))
FORMATS=config.get(CFG_S_GLOBAL,'formats')
DUBLICATES=config.getboolean(CFG_S_GLOBAL,'dublicates')

EXT_LIST=FORMATS.upper().split()

if VERBOSE:
        print('Config file read: DB_NAME =',DB_NAME,', DB_USER =',DB_USER,', DB_PASS =',DB_PASS,', DB_HOST =',DB_HOST,', ROOT_LIB =',ROOT_LIB,', FORMATS =',FORMATS,', DUBLICATES =',DUBLICATES)

###########################################################################
# Класс доступа к  MYSQL
#

class opdsDatabase:
  def __init__(self,iname,iuser,ipass,ihost):
    self.db_name=iname
    self.db_user=iuser
    self.db_pass=ipass
    self.db_host=ihost
    self.errcode=0
    self.err=""
    self.isopen=False

  def openDB(self):
    if not self.isopen:
      try:
         # buffered=true сделано для того чтобы избежать выборки fetchall при поиске книг и тэгов
         self.cnx = mysql.connector.connect(user=self.db_user, password=self.db_pass, host=self.db_host, database=self.db_name, buffered=True)
      except mysql.connector.Error as err:
         if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
            self.err="Something is wrong with your user name or password"
            self.errcode=1
         elif err.errno == errorcode.ER_BAD_DB_ERROR:
            self.err="Database does not exists"
            self.errcode=2
         else:
            self.err=err
            self.errcode=3
      else:
         self.isopen=True
    else:
      self.errcode=4
      self.err="Error open database. Database Already open."

  def closeDB(self):
    if self.isopen:
      self.cnx.close()
      self.isopen=False
    else:
      self.errcode=5
      self.err="Attempt to close not opened database."

  def printDBerr(self):
    if self.errcode==0:
       print("No Database Error found.")
    else:
       print("Error Code =",self.errcode,". Error Message:",self.err)

  def clearDBerr(self):
    self.err=""
    self.errcode=0

  def findtag(self,tag):
    sql_findtag=("select tag_id from "+TBL_TAGS+" where tag='"+tag+"'")
    cursor=self.cnx.cursor()
    cursor.execute(sql_findtag)
    row=cursor.fetchone()
    if row==None:
       tag_id=0
    else:
       tag_id=row[0]
       if VERBOSE:
          print("Tag '"+tag+"' already in database with tag_id=",tag_id)
    cursor.close()
    return tag_id

  def findbook(self, name, path):
    sql_findbook=("select book_id from "+TBL_BOOKS+" where filename=%s and fullpath=%s")
    data_findbook=(name,path)
    cursor=self.cnx.cursor()
    cursor.execute(sql_findbook,data_findbook)
    row=cursor.fetchone()
    if row==None:
       book_id=0
    else:
       book_id=row[0]
       if VERBOSE:
          print("Book '"+name+"' already in database with book_id=",book_id)
    cursor.close()
    return book_id

  def findbtag(self, book_id, tag_id):
    sql_findbtag=("select book_id from "+TBL_BTAGS+" where book_id=%s and tag_id=%s")
    data_findbtag=(book_id,tag_id)
    cursor=self.cnx.cursor()
    cursor.execute(sql_findbtag,data_findbtag)
    row=cursor.fetchone()
    result=(row!=None)
    cursor.close()
    return result
 
  def addbook(self, name, path, cat_id, size=0):
    book_id=self.findbook(name,path)
    if book_id!=0:
       return book_id
    sql_addbook=("insert into "+TBL_BOOKS+"(filename,fullpath,cat_id,filesize) VALUES(%s, %s, %s, %s)")
    data_addbook=(name,path,cat_id,size)
    if VERBOSE:
       print(sql_addbook, data_addbook)
    cursor=self.cnx.cursor()
    cursor.execute(sql_addbook,data_addbook)
    book_id=cursor.lastrowid
    self.cnx.commit()
    cursor.close()
    return book_id
    
  def addtag(self, tag, tag_type=0):
    tag_id=self.findtag(tag)
    if tag_id!=0:
       return tag_id
    sql_addtag=("insert into "+TBL_TAGS+"(tag,tag_type) VALUES(%s,%s)")
    data_addtag=(tag,tag_type)
    if VERBOSE:
       print(sql_addtag, data_addtag)
    cursor=self.cnx.cursor()
    cursor.execute(sql_addtag,data_addtag)
    tag_id=cursor.lastrowid
    self.cnx.commit()
    cursor.close()
    return tag_id

  def addbtag(self, book_id, tag_id):
    if not self.findbtag(book_id,tag_id):
       sql_addbtag=("insert into "+TBL_BTAGS+"(book_id,tag_id) VALUES(%s,%s)")
       data_addbtag=(book_id,tag_id)
       cursor=self.cnx.cursor()
       cursor.execute(sql_addbtag,data_addbtag)
       btag_id=cursor.lastrowid
       self.cnx.commit()
       cursor.close()

  def findcat(self, catalog):
    (head,tail)=os.path.split(catalog)
    sql_findcat=("select cat_id from "+TBL_CATALOGS+" where cat_name=%s and full_path=%s")
    data_findcat=(tail,catalog)
    cursor=self.cnx.cursor()
    cursor.execute(sql_findcat,data_findcat)
    row=cursor.fetchone()
    if row==None:
       cat_id=0
    else:
       cat_id=row[0]
       if VERBOSE:
          print("Catalog '"+tail+"' already in database with cat_id=",cat_id," and full_path=",catalog)
    cursor.close()
    return cat_id

  def addcattree(self, catalog, root):
    cat_id=self.findcat(catalog)
    if cat_id!=0:
       return cat_id 
    if catalog==root:
       return 0
    (head,tail)=os.path.split(catalog)
    parent_id=self.addcattree(head,root)
    sql_addcat=("insert into "+TBL_CATALOGS+"(parent_id,cat_name,full_path) VALUES(%s, %s, %s)")
    data_addcat=(parent_id,tail,catalog)
    cursor=self.cnx.cursor()
    cursor.execute(sql_addcat,data_addcat)
    cat_id=cursor.lastrowid
    self.cnx.commit()
    cursor.close()
    return cat_id

  def __del__(self):
    self.closeDB()

###########################################################################
# Основной код программы
#

opdsdb=opdsDatabase(DB_NAME,DB_USER,DB_PASS,DB_HOST)
opdsdb.openDB()
opdsdb.printDBerr()

extensions_set={x for x in EXT_LIST}
if VERBOSE:
   print(extensions_set)

for full_path, dirs, files in os.walk(ROOT_LIB):
  for name in files:
    (n,e)=os.path.splitext(name)
    if e.upper() in extensions_set:
       head=full_path
       cat_id=opdsdb.addcattree(full_path, ROOT_LIB)
       book_id=opdsdb.addbook(name,full_path,cat_id)
       if VERBOSE:
          print("Added book: ",full_path," - ",name)

#       while head!=ROOT_LIB :
#         (head,tag)=os.path.split(head)
#         tag_id=opdsdb.addtag(tag)
#         opdsdb.addbtag(book_id,tag_id)

opdsdb.closeDB()

